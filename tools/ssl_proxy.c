//gcc ssl_cli.c -lssl -lcrypto
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>
#include <linux/types.h>
#include <asm/byteorder.h>
#include <linux/ip.h>
//#include <linux/tcp.h>
#include <netinet/tcp.h>

#define BUF_SIZE 512 *1024
SSL *ssl_s;
SSL *ssl_c;

int create_server(short port)
{
	int fd = -1;
	struct sockaddr_in addr;

	memset(&addr, 0, sizeof(addr));
	
	fd = socket(PF_INET, SOCK_STREAM, 0);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = INADDR_ANY;
	if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
	{
		perror("can't bind port");
		return -1;
	}
	if (listen(fd, 5) != 0)
	{
		perror("Can't listen port");
		return -1;
	}
	
	return fd;
}

int load_cert_key_file(SSL_CTX *ctx, char *cert_file, char *key_file)
{
	if (SSL_CTX_load_verify_locations(ctx, cert_file, key_file) != 1)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	
	if (SSL_CTX_set_default_verify_paths(ctx) != 1)
	{
        ERR_print_errors_fp(stderr);
		return -1;
	}

	/* set the local certificate from CertFile */
	if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* set the private key from KeyFile (may be the same as CertFile) */
	if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* verify private key */
	if (!SSL_CTX_check_private_key(ctx))
	{
		fprintf(stderr, "Private key does not match the public certificate\n");
		return -1;
	}
	printf("Load Certificates and key Complete Successfully.....\n");

	return 0;
}

int init_ssl_ser(int fd, SSL_CTX **ctx, SSL **ssl, char *cert_file, char *key_file)
{
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	*ctx = SSL_CTX_new(TLSv1_2_server_method());
	if (load_cert_key_file(*ctx, cert_file, key_file) == -1)
	{
		return -1;
	}
	*ssl = SSL_new(*ctx);
	SSL_set_fd(*ssl, fd);
	if (SSL_accept(*ssl) == -1)	   /* do SSL-protocol accept */
		return -1;

	return 0;
}

//connect hostname or ip
int connect_server(char *server, short port, int type)
{
	int fd = -1;
	struct sockaddr_in ser;
	struct hostent *host = NULL;

	memset(&ser, 0, sizeof(ser));
	ser.sin_family = AF_INET;  
	ser.sin_port = htons(port);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0)
	{
		perror("socket");
		return fd;
	}

	if (type == 0)
	{
		if (inet_aton(server, (struct in_addr *)&ser.sin_addr.s_addr) == 0)  
		{  
			perror(server);  
			return -1; 
		}
	}
	else
	{
		if ((host = gethostbyname(server)) == NULL)
		{
		    printf("error: %s\n",server);
			return -1;
		}
		ser.sin_addr.s_addr = *(long*)(host->h_addr);
	}
	
	if (connect(fd, (struct sockaddr *)&ser, sizeof(ser)) != 0)  
	{  
		perror("Connect ");  
		return -1; 
	}

	return fd;
}

// print certificate info
static void show_certs(SSL *ssl)
{
	X509 *cert;
	char *line = NULL;

	cert = SSL_get_peer_certificate(ssl);
	if (cert != NULL) 
	{
		printf("Cert Information:\n");
		line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
		if (line)
		{
			printf("Cert: %s\n", line);
			free(line);
			line = NULL;
		}
		line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
		if (line)
		{
			printf("Author: %s\n", line);
			free(line);
			line = NULL;
		}
		X509_free(cert);
	}
	else 
	{
		printf("There is no cert information！\n");
	}
	return;
}

int init_ssl_cli(int fd, SSL_CTX **ctx, SSL **ssl)
{
	static SSL_CTX ctx_tmp;
	static SSL ssl_tmp;
	
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	*ctx = SSL_CTX_new(TLSv1_2_client_method());
	if (*ctx == NULL)
	{
		printf("SSL_CTX_new error.\n");
		return -1;
	}

	*ssl = SSL_new(*ctx);
	SSL_set_fd(*ssl, fd);
	if (SSL_connect(*ssl) < 0)
	{
		return -1;
	}

	return 0;
}

int get_tcp_stat(int sock) 
{ 
	if(sock <= 0) 
		return -1;
	
	struct tcp_info info; 
	int len = sizeof(info); 

	memset(&info, 0, sizeof(info));
	getsockopt(sock, IPPROTO_TCP, TCP_INFO, &info, (socklen_t *)&len); 
	if((info.tcpi_state==TCP_ESTABLISHED)) 
	{
		return 0; 
	} 
	else 
	{ 
		return -1; 
	} 
}

void *data_stoc(void *arg)
{
	int rlen = 0;
	int wlen = 0;
	char buf[512 * 1024] = {0};
	
	while (1)
	{
		memset(buf, 0, sizeof(buf));
		rlen = SSL_read(ssl_s, buf, sizeof(buf) - 1);
		if (rlen <= 0)
		{
			usleep(100000);
			continue;
		}

		//printf("----------------data_stoc = %d\n%s\n", rlen, buf);
		wlen = SSL_write(ssl_c, buf, rlen);
		if (wlen != rlen)
		{
			usleep(100000);
			continue;		
		}
	}
}

void *data_ctos(void *arg)
{
	int rlen = 0;
	int wlen = 0;
	char buf[512 * 1024] = {0};
	
	while (1)
	{
		memset(buf, 0, sizeof(buf));
		rlen = SSL_read(ssl_c, buf, sizeof(buf));
		if (rlen <= 0)
		{
			usleep(100000);
			continue;
		}

		printf("---------------data_ctos = %d\n%s\n", rlen, buf);
		wlen = SSL_write(ssl_s, buf, rlen);
		if (wlen != rlen)
		{
			usleep(100000);
			continue;		
		}
	}
}

void free_ssl(SSL_CTX *ctx, SSL *ssl)
{
	SSL_shutdown(ssl);  
	SSL_free(ssl);
	SSL_CTX_free(ctx);
	return;
}

int main(int argc, char **argv)
{
	SSL_CTX *ctx_s = NULL;
	SSL_CTX *ctx_c = NULL;

	char *cert_file = NULL;
	char *key_file = NULL;
	char *server_addr = NULL;
	short lport = 0;
	short server_port = 0;
	int sockfd = -1;
	int serverfd = -1;
	struct sockaddr_in addr;
	int c_fd = -1;
	int len = sizeof(addr);
	pthread_t tid1;
	pthread_t tid2;
	int ret = -1;

	memset(&addr, 0, sizeof(addr));

	if (argc != 6)
		return -1;
	
	lport = atoi(argv[1]);
	server_addr = argv[2];
	server_port = atoi(argv[3]);
	cert_file = argv[4];
	key_file = argv[5];
	
	//连接https服务器
	sockfd = connect_server(server_addr, server_port, 1);
	if (sockfd < 0)
	{
		printf("connect_server error, errno = %d.\n", errno);
		exit(-1);
	}

	init_ssl_cli(sockfd, &ctx_c, &ssl_c);
	printf("init ssl success, fd = %d\n", sockfd);
	show_certs(ssl_c);

	//创建本地ssl server
	serverfd = create_server(lport);
	if (serverfd < 0)
	{
		printf("create_server error, errno = %d.\n", errno);
		exit(-1);
	}

	//只要一路连接，关闭server fd
	c_fd = accept(serverfd, (struct sockaddr*)&addr, &len);
	printf("Connection: %s:%d, fd = %d\n",inet_ntoa(addr.sin_addr), ntohs(addr.sin_port), c_fd);
	close(serverfd);
	init_ssl_ser(c_fd, &ctx_s, &ssl_s, cert_file, key_file);
	show_certs(ssl_s);

	ret = pthread_create(&tid1, NULL, data_ctos, NULL);
	if (ret < 0)
	{
		printf("pthread_create: data_ctos error, errno = %d\n", errno);
		return -1;
	}

	ret = pthread_create(&tid1, NULL, data_stoc, NULL);
	if (ret < 0)
	{
		printf("pthread_create: data_ctos error, errno = %d\n", errno);
		return -1;
	}

	while (1)
	{
		if ((get_tcp_stat(c_fd) < 0) || (get_tcp_stat(sockfd) < 0))
		{
			break;
		}
		sleep(10);
	}

	pthread_cancel(tid1);
	pthread_cancel(tid2);
	free_ssl(ctx_s, ssl_s);
	close(c_fd); 
	free_ssl(ctx_c, ssl_c);
	close(sockfd);		
	return -1;
}

