//gcc ssl_cli.c -lssl -lcrypto
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>

#define BUF_SIZE 512 *1024

char cs_buf[BUF_SIZE];
char sc_buf[BUF_SIZE];

int create_server(short port)
{
	int fd = -1;
	struct sockaddr_in addr;

	memset(&addr, 0, sizeof(addr));
	
	fd = socket(PF_INET, SOCK_STREAM, 0);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = INADDR_ANY;
	if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
	{
		perror("can't bind port");
		return -1;
	}
	if (listen(fd, 5) != 0)
	{
		perror("Can't listen port");
		return -1;
	}
	
	return fd;
}

//connect hostname or ip
int connect_server(char *server, short port, int type)
{
	int fd = -1;
	struct sockaddr_in ser;
	struct hostent *host = NULL;

	memset(&ser, 0, sizeof(ser));
	ser.sin_family = AF_INET;  
	ser.sin_port = htons(port);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0)
	{
		perror("socket");
		return fd;
	}

	if (type == 0)
	{
		if (inet_aton(server, (struct in_addr *)&ser.sin_addr.s_addr) == 0)  
		{  
			perror(server);  
			return -1; 
		}
	}
	else
	{
		if ((host = gethostbyname(server)) == NULL)
		{
		    printf("error: %s\n",server);
			return -1;
		}
		ser.sin_addr.s_addr = *(long*)(host->h_addr);
	}
	
	if (connect(fd, (struct sockaddr *)&ser, sizeof(ser)) != 0)  
	{  
		perror("Connect ");  
		return -1; 
	}

	return fd;
}

// print certificate info
static void show_certs(SSL * ssl)
{
	X509 *cert;
	char *line = NULL;

	cert = SSL_get_peer_certificate(ssl);
	if (cert != NULL) 
	{
		printf("Cert Information:\n");
		line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
		if (line)
		{
			printf("Cert: %s\n", line);
			free(line);
			line = NULL;
		}
		line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
		if (line)
		{
			printf("Author: %s\n", line);
			free(line);
			line = NULL;
		}
		X509_free(cert);
	}
	else 
	{
		printf("There is no cert information！\n");
	}
	return;
}

int load_cert_key_file(SSL_CTX *ctx, char *cert_file, char *key_file)
{
	if (SSL_CTX_load_verify_locations(ctx, cert_file, key_file) != 1)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	
	if (SSL_CTX_set_default_verify_paths(ctx) != 1)
	{
        ERR_print_errors_fp(stderr);
		return -1;
	}

	/* set the local certificate from CertFile */
	if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* set the private key from KeyFile (may be the same as CertFile) */
	if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* verify private key */
	if (!SSL_CTX_check_private_key(ctx))
	{
		fprintf(stderr, "Private key does not match the public certificate\n");
		return -1;
	}
	printf("Load Certificates and key Complete Successfully.....\n");

	return 0;
}

//有问题，二维指针问题
int init_ssl_conn(int fd, SSL_CTX **ctx, SSL **ssl)
{
	static SSL_CTX ctx_tmp;
	static SSL ssl_tmp;
	
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	*ctx = SSL_CTX_new(TLSv1_2_client_method());
	if (*ctx == NULL)
	{
		printf("SSL_CTX_new error.\n");
		return -1;
	}

	*ssl = SSL_new(*ctx);
	SSL_set_fd(*ssl, fd);
	if (SSL_connect(*ssl) < 0)
	{
		return -1;
	}

	return 0;
}

void rw_ssl_connection(SSL *ssl)
{
	char buf[512 * 1024] = {0};
	int len = 0;
	
	while(1)
	{
		memset(buf, 0, sizeof(buf));
		len = SSL_read(ssl, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		printf("len = %d.\n%s\n", len, buf);
		//len = snprintf(buf + len, sizeof(buf) - len, "%s", " -write.\n");
		len = SSL_write(ssl, buf, len);
		if (len < 0)
		{
			sleep(1);
			continue;
		}		
	}
	return;
}





// read and write ssl connection
void rw_ssl_conn(SSL *ssl)
{
	char buf[512 * 1024] = {0};
	int len = 0;

	while (1)
	{
		memset(buf, 0, sizeof(buf));
		len = read(0, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		len = SSL_write(ssl, buf, len);
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		memset(buf, 0, sizeof(buf));
		len = SSL_read(ssl, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		printf ("len = %d\n%s\n\n#", len, buf);
		
	}
	return;
}

int ssl_client(char *addr, short port)
{
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	int sockfd = -1;
	char buf[512 * 1024] = {0};
	int len = 0;
	
	sockfd = connect_server(addr, port, 1);
	if (sockfd < 0)
	{
		printf("connect_server error, errno = %d.\n", errno);
		exit(-1);
	}

	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	ctx = SSL_CTX_new(TLSv1_2_client_method());
	if (ctx == NULL)
	{
		printf("SSL_CTX_new error.\n");
		return -1;
	}

	ssl = SSL_new(ctx);
	SSL_set_fd(ssl, sockfd);
	if (SSL_connect(ssl) < 0)
	{
		return -1;
	}

	show_certs(ssl);
	rw_ssl_conn(ssl);

	SSL_shutdown(ssl);  
	SSL_free(ssl);
	close(sockfd);
	SSL_CTX_free(ctx);
	return 0;
}

int ssl_server(short port, char *cert_file, char *key_file)
{
	SSL_CTX *ctx;
	SSL *ssl;
	int sockfd = -1;
	struct sockaddr_in addr;
	int c_fd = -1;
	int len = sizeof(addr);
	
	memset(&addr, 0, sizeof(addr));
	if (argc < 4)
		return -1;
	
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	ctx = SSL_CTX_new(TLSv1_2_server_method());

	if (load_cert_key_file(ctx, cert_file, key_file) == -1)
		return -1;

	sockfd = create_server(port);
	if (sockfd < 0)
		return -1;

	c_fd = accept(sockfd, (struct sockaddr*)&addr, &len);
	printf("Connection: %s:%d, fd = %d\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port), c_fd);
	ssl = SSL_new(ctx);
	SSL_set_fd(ssl, c_fd);
	if (SSL_accept(ssl) == -1)	   /* do SSL-protocol accept */
		return -1;
	
	show_certs(ssl);

	rw_ssl_connection(ssl);

	SSL_shutdown(ssl);
	SSL_free(ssl);
	close(sockfd);
	close(c_fd);          /* close server socket */
	SSL_CTX_free(ctx); 

	return -1;
}

int main(int argc, char **argv)
{
	if (argc != 6)
		return -1;
	
	int ret = -1;
	pthread_t tid1;
	pthread_t tid2;
	short lport = 0;
	short server_port = 0;
	char *server_ip = NULL;
	char *cert_file = NULL;
	char *key_file = NULL;
	
	lport = atoi(argv[1]);
	server_ip = argv[2];
	server_port = atoi(argv[3]);
	cert_file = argv[4];
	key_file = argv[5];
	
	ret = pthread_create(&tid1, NULL, ssl_server, &lport, cert_file, key_file);
	ret = pthread_create(&tid2, NULL, ssl_client, server_ip, &server_port);

	while(1)
		sleep(10);

	return 0;
}



