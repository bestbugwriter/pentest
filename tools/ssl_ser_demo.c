//gcc ssl_cli.c -lssl -lcrypto
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

int create_server(short port)
{
	int fd = -1;
	struct sockaddr_in addr;

	memset(&addr, 0, sizeof(addr));
	
	fd = socket(PF_INET, SOCK_STREAM, 0);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = INADDR_ANY;
	if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
	{
		perror("can't bind port");
		return -1;
	}
	if (listen(fd, 5) != 0)
	{
		perror("Can't listen port");
		return -1;
	}
	
	return fd;
}

int load_cert_key_file(SSL_CTX *ctx, char *cert_file, char *key_file)
{
	if (SSL_CTX_load_verify_locations(ctx, cert_file, key_file) != 1)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	
	if (SSL_CTX_set_default_verify_paths(ctx) != 1)
	{
        ERR_print_errors_fp(stderr);
		return -1;
	}

	/* set the local certificate from CertFile */
	if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* set the private key from KeyFile (may be the same as CertFile) */
	if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stderr);
		return -1;
	}
	/* verify private key */
	if (!SSL_CTX_check_private_key(ctx))
	{
		fprintf(stderr, "Private key does not match the public certificate\n");
		return -1;
	}
	printf("Load Certificates and key Complete Successfully.....\n");

	return 0;
}

int init_ssl_ser(int fd, SSL_CTX **ctx, SSL **ssl, char *cert_file, char *key_file)
{
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	*ctx = SSL_CTX_new(TLSv1_2_server_method());
	if (load_cert_key_file(*ctx, cert_file, key_file) == -1)
	{
		return -1;
	}
	*ssl = SSL_new(*ctx);
	SSL_set_fd(*ssl, fd);
	if (SSL_accept(*ssl) == -1)	   /* do SSL-protocol accept */
		return -1;

	return 0;
}

void free_ssl(SSL_CTX *ctx, SSL *ssl)
{
	SSL_shutdown(ssl);  
	SSL_free(ssl);
	SSL_CTX_free(ctx);
	return;
}

void rw_ssl_connection(SSL *ssl)
{
	char buf[512 * 1024] = {0};
	int len = 0;
	
	while(1)
	{
		memset(buf, 0, sizeof(buf));
		len = SSL_read(ssl, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		printf("len = %d.\n%s\n", len, buf);
		len = SSL_write(ssl, buf, len);
		if (len < 0)
		{
			sleep(1);
			continue;
		}		
	}
	return;
}

void ShowCerts(SSL* ssl)
{   
	X509 *cert;
	char *line;
	cert = SSL_get_peer_certificate(ssl); /* Get certificates (if available) */
	if ( cert != NULL )
	{
		printf("Server certificates:\n");
		line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
		printf("Subject: %s\n", line);
		free(line);
		line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
		printf("Issuer: %s\n", line);
		free(line);
		X509_free(cert);
	}
	else
		printf("No certificates.\n");
}

int main(int argc, char **argv)
{
	SSL_CTX *ctx;
	SSL *ssl;
	char *cert_file = NULL;
	char *key_file = NULL;
	short port = 0;
	int sockfd = -1;
	struct sockaddr_in addr;
	int c_fd = -1;
	int len = sizeof(addr);
	
	memset(&addr, 0, sizeof(addr));
	if (argc < 4)
		return -1;

	port = atoi(argv[1]);
	cert_file = argv[2];
	key_file = argv[3];
	printf("%d, %s, %s.\n", port, cert_file, key_file);

	sockfd = create_server(port);
	if (sockfd < 0)
		return -1;

	c_fd = accept(sockfd, (struct sockaddr*)&addr, &len);
	printf("Connection: %s:%d, fd = %d\n",inet_ntoa(addr.sin_addr), ntohs(addr.sin_port), c_fd);
	init_ssl_ser(c_fd, &ctx, &ssl, cert_file, key_file);
	ShowCerts(ssl);

	rw_ssl_connection(ssl);
	free_ssl(ctx, ssl);
	close(c_fd); 
	
	close(sockfd);

	return -1;
}
