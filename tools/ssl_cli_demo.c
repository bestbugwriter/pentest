//gcc ssl_cli.c -lssl -lcrypto
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

//connect hostname or ip
int connect_server(char *server, short port, int type)
{
	int fd = -1;
	struct sockaddr_in ser;
	struct hostent *host = NULL;

	memset(&ser, 0, sizeof(ser));
	ser.sin_family = AF_INET;  
	ser.sin_port = htons(port);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0)
	{
		perror("socket");
		return fd;
	}

	if (type == 0)
	{
		if (inet_aton(server, (struct in_addr *)&ser.sin_addr.s_addr) == 0)  
		{  
			perror(server);  
			return -1; 
		}
	}
	else
	{
		if ((host = gethostbyname(server)) == NULL)
		{
		    printf("error: %s\n",server);
			return -1;
		}
		ser.sin_addr.s_addr = *(long*)(host->h_addr);
	}
	
	if (connect(fd, (struct sockaddr *)&ser, sizeof(ser)) != 0)  
	{  
		perror("Connect ");  
		return -1; 
	}

	return fd;
}

// print certificate info
static void show_certs(SSL *ssl)
{
	X509 *cert;
	char *line = NULL;

	cert = SSL_get_peer_certificate(ssl);
	if (cert != NULL) 
	{
		printf("Cert Information:\n");
		line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
		if (line)
		{
			printf("Cert: %s\n", line);
			free(line);
			line = NULL;
		}
		line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
		if (line)
		{
			printf("Author: %s\n", line);
			free(line);
			line = NULL;
		}
		X509_free(cert);
	}
	else 
	{
		printf("There is no cert information£¡\n");
	}
	return;
}

int init_ssl_cli(int fd, SSL_CTX **ctx, SSL **ssl)
{
	static SSL_CTX ctx_tmp;
	static SSL ssl_tmp;
	
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	*ctx = SSL_CTX_new(TLSv1_2_client_method());
	if (*ctx == NULL)
	{
		printf("SSL_CTX_new error.\n");
		return -1;
	}

	*ssl = SSL_new(*ctx);
	SSL_set_fd(*ssl, fd);
	if (SSL_connect(*ssl) < 0)
	{
		return -1;
	}

	return 0;
}

// read and write ssl connection
void rw_ssl_conn(SSL *ssl)
{
	char buf[512 * 1024] = {0};
	int len = 0;

	while (1)
	{
		memset(buf, 0, sizeof(buf));
		len = read(0, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		len = SSL_write(ssl, buf, len);
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		memset(buf, 0, sizeof(buf));
		len = SSL_read(ssl, buf, sizeof(buf));
		if (len < 0)
		{
			sleep(1);
			continue;
		}

		printf ("len = %d\n%s\n\n#", len, buf);
		
	}
	return;
}

void free_ssl(SSL_CTX *ctx, SSL *ssl)
{
	SSL_shutdown(ssl);  
	SSL_free(ssl);
	SSL_CTX_free(ctx);
	return;
}

int main(int argc, char **argv)
{
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	int sockfd = -1;
	char buf[512 * 1024] = {0};
	int len = 0;

	if (argc < 3)
	{
		return -1;
	}

	sockfd = connect_server(argv[1], atoi(argv[2]), 1);
	if (sockfd < 0)
	{
		printf("connect_server error, errno = %d.\n", errno);
		exit(-1);
	}

	init_ssl_cli(sockfd, &ctx, &ssl);
	printf("init ssl success, fd = %d\n", sockfd);
	show_certs(ssl);

	rw_ssl_conn(ssl);

	free_ssl(ctx, ssl);
	close(sockfd);
	return 0;
}